#!/bin/bash
# Sync Status Monitoring Script
# Autogenerated by Ansible from sync-monitor.sh.j2
#
# This script monitors the synchronization status of Ethereum execution and consensus clients
# and logs the data for later analysis and visualization.

# Configuration from Ansible
EL_CLIENT="{{ el_client }}"
CL_CLIENT="{{ cl_client }}"
EL_CONTAINER="{{ el_container_name }}"
CL_CONTAINER="{{ cl_container_name }}"
CHECK_INTERVAL="{{ check_interval }}"
LOG_FILE="{{ log_file }}"
HISTORY_FILE="{{ history_path }}"
MONITOR_TIME="{{ monitor_time }}"
HOST_DATA_DIR="{{ host_data_dir }}"

# Ensure log directory exists
mkdir -p "$(dirname "$LOG_FILE")"

# Initialize JSON history file if it doesn't exist
if [ ! -f "$HISTORY_FILE" ]; then
    echo '{"sync_history": []}' > "$HISTORY_FILE"
fi

# Function to get current timestamp
get_timestamp() {
    date +"%Y-%m-%d %H:%M:%S"
}

# Function to log messages
log_message() {
    local timestamp=$(get_timestamp)
    echo "[$timestamp] $1" | tee -a "$LOG_FILE"
}

# Function to get Geth sync status
get_geth_sync_status() {
    if ! docker exec "$EL_CONTAINER" geth --exec 'eth.syncing' attach /data/geth.ipc 2>/dev/null; then
        echo "error: Unable to connect to geth IPC"
        return 1
    fi
}

# Function to get Geth detailed sync status
get_geth_detailed_status() {
    local output
    local currentBlock
    local highestBlock

    # Get syncing status (could be 'false' if fully synced)
    output=$(docker exec "$EL_CONTAINER" geth --exec 'eth.syncing' attach /data/geth.ipc 2>/dev/null)

    if [[ "$output" == "false" ]]; then
        # Node is synced, get current block
        currentBlock=$(docker exec "$EL_CONTAINER" geth --exec 'eth.blockNumber' attach /data/geth.ipc 2>/dev/null)
        echo "sync: complete, current_block: $currentBlock, highest_block: $currentBlock, synced: true"
    else
        # Try to parse the JSON output to get current and highest block
        # Example output: {currentBlock: 1234, highestBlock: 5678, ...}
        currentBlock=$(echo "$output" | grep -oP 'currentBlock: \K[0-9]+' || echo "unknown")
        highestBlock=$(echo "$output" | grep -oP 'highestBlock: \K[0-9]+' || echo "unknown")

        # Calculate progress percentage if both values are numbers
        if [[ "$currentBlock" =~ ^[0-9]+$ ]] && [[ "$highestBlock" =~ ^[0-9]+$ ]] && [ "$highestBlock" -gt 0 ]; then
            progress=$(( (currentBlock * 100) / highestBlock ))
        else
            progress="unknown"
        fi

        echo "sync: in_progress, current_block: $currentBlock, highest_block: $highestBlock, progress: $progress%, synced: false"
    fi
}

# Function to get Lighthouse sync status
get_lighthouse_sync_status() {
    docker exec "$CL_CONTAINER" lighthouse bn sync_status 2>/dev/null || echo "error: Unable to get Lighthouse sync status"
}

# Function to get Lighthouse detailed status
get_lighthouse_detailed_status() {
    local output
    local syncDistance
    local headSlot
    local status="unknown"

    output=$(docker exec "$CL_CONTAINER" lighthouse bn sync_status 2>/dev/null)

    if echo "$output" | grep -q "Synced"; then
        status="synced"
        syncDistance="0"
        headSlot=$(echo "$output" | grep -oP 'head slot: \K[0-9]+' || echo "unknown")
    else
        status="syncing"
        syncDistance=$(echo "$output" | grep -oP 'distance: \K[0-9]+' || echo "unknown")
        headSlot=$(echo "$output" | grep -oP 'head slot: \K[0-9]+' || echo "unknown")
    fi

    echo "status: $status, sync_distance: $syncDistance, head_slot: $headSlot"
}

# Function to collect system metrics
get_system_metrics() {
    # CPU usage percentage
    local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2 + $4}')

    # Memory usage percentage
    local mem_usage=$(free | grep Mem | awk '{print $3/$2 * 100.0}')

    # Disk usage percentage for data directory
    local disk_usage=$(df -h "$HOST_DATA_DIR" | awk 'NR==2 {print $5}' | tr -d '%')

    echo "cpu: $cpu_usage%, memory: $mem_usage%, disk: $disk_usage%"
}

# Function to add entry to JSON history file
add_to_history() {
    local timestamp=$(date +"%s")
    local date_human=$(date +"%Y-%m-%d %H:%M:%S")
    local el_status="$1"
    local cl_status="$2"
    local sys_metrics="$3"

    # Parse current JSON file
    local temp_file=$(mktemp)

    # Extract current blocks if available
    local current_block=$(echo "$el_status" | grep -oP 'current_block: \K[0-9]+' || echo "null")
    local highest_block=$(echo "$el_status" | grep -oP 'highest_block: \K[0-9]+' || echo "null")
    local el_synced=$(echo "$el_status" | grep -oP 'synced: \K(true|false)' || echo "null")

    # Extract consensus metrics if available
    local cl_sync_distance=$(echo "$cl_status" | grep -oP 'sync_distance: \K[0-9]+' || echo "null")
    local cl_head_slot=$(echo "$cl_status" | grep -oP 'head_slot: \K[0-9]+' || echo "null")
    local cl_status_text=$(echo "$cl_status" | grep -oP 'status: \K\w+' || echo "null")

    # Extract system metrics
    local cpu_usage=$(echo "$sys_metrics" | grep -oP 'cpu: \K[0-9.]+' || echo "null")
    local mem_usage=$(echo "$sys_metrics" | grep -oP 'memory: \K[0-9.]+' || echo "null")
    local disk_usage=$(echo "$sys_metrics" | grep -oP 'disk: \K[0-9.]+' || echo "null")

    # Create JSON entry
    local new_entry="{\"timestamp\": $timestamp, \"date\": \"$date_human\", \"el_client\": \"$EL_CLIENT\", \"cl_client\": \"$CL_CLIENT\", \"current_block\": $current_block, \"highest_block\": $highest_block, \"el_synced\": $el_synced, \"cl_sync_distance\": $cl_sync_distance, \"cl_head_slot\": $cl_head_slot, \"cl_status\": \"$cl_status_text\", \"cpu_usage\": $cpu_usage, \"mem_usage\": $mem_usage, \"disk_usage\": $disk_usage}"

    # Add to history array
    jq ".sync_history += [$new_entry]" "$HISTORY_FILE" > "$temp_file" && mv "$temp_file" "$HISTORY_FILE"
}

# Main monitoring loop
log_message "Starting sync status monitoring for $EL_CLIENT and $CL_CLIENT"
log_message "Logging to $LOG_FILE and collecting history in $HISTORY_FILE"
log_message "Checking every $CHECK_INTERVAL seconds for $MONITOR_TIME seconds"

start_time=$(date +%s)
end_time=$((start_time + MONITOR_TIME))

while [ $(date +%s) -lt $end_time ]; do
    timestamp=$(get_timestamp)

    # Get execution client status
    log_message "Checking $EL_CLIENT sync status..."
    el_status=$(get_geth_detailed_status)
    log_message "$EL_CLIENT: $el_status"

    # Get consensus client status
    log_message "Checking $CL_CLIENT sync status..."
    cl_status=$(get_lighthouse_detailed_status)
    log_message "$CL_CLIENT: $cl_status"

    # Get system metrics
    sys_metrics=$(get_system_metrics)
    log_message "System: $sys_metrics"

    # Add to history
    add_to_history "$el_status" "$cl_status" "$sys_metrics"

    log_message "---"
    sleep $CHECK_INTERVAL
done

log_message "Sync status monitoring complete after $(( ($(date +%s) - start_time) / 60 )) minutes"
exit 0
