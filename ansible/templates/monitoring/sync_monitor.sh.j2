#!/bin/bash

# Synchronization Status Monitoring Script
# Autogenerated by Ansible from sync_monitor.sh.j2

MONITOR_DIR="{{ ephemery_base_dir }}/data/monitoring/sync"
HISTORY_FILE="${MONITOR_DIR}/history.json"
CURRENT_FILE="${MONITOR_DIR}/current_status.json"
HISTORY_SIZE="{{ sync_history_points | default(100) }}"
EL_CLIENT="{{ el }}"
CL_CLIENT="{{ cl }}"

# Create monitoring directory if it doesn't exist
mkdir -p "${MONITOR_DIR}"

# Beacon node RPC endpoint
BEACON_ENDPOINT="http://localhost:{{ '4000' if cl == 'prysm' else '5052' }}"

# Execution client RPC endpoint
EXECUTION_ENDPOINT="http://localhost:8545"

# Ensure log file exists
touch "${MONITOR_DIR}/monitor.log"

# Helper function to log messages
log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "${MONITOR_DIR}/monitor.log"
}

# Initialize history file if it doesn't exist
if [ ! -f "${HISTORY_FILE}" ]; then
    echo '{"sync_history":[]}' > "${HISTORY_FILE}"
    log_message "Created new history file"
fi

# Get execution client sync status
get_execution_status() {
    local current_block="unknown"
    local highest_block="unknown"
    local is_syncing=true
    local sync_percentage="unknown"

    # Get execution sync status
    local sync_status=$(curl -s -X POST -H "Content-Type: application/json" --data '{"jsonrpc":"2.0","method":"eth_syncing","params":[],"id":1}' ${EXECUTION_ENDPOINT})

    if [ $? -ne 0 ]; then
        log_message "Error: Failed to connect to execution client"
        echo '{"is_syncing":true,"current_block":"unknown","highest_block":"unknown","sync_percentage":"unknown"}'
        return
    fi

    # Check if node is syncing
    if echo "$sync_status" | grep -q "false"; then
        is_syncing=false

        # Get current block when fully synced
        local block_response=$(curl -s -X POST -H "Content-Type: application/json" --data '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}' ${EXECUTION_ENDPOINT})
        if [ $? -eq 0 ]; then
            current_block=$(echo "$block_response" | grep -o '"result":"0x[^"]*' | cut -d'"' -f4)
            current_block=$((16#${current_block:2}))
            highest_block=$current_block
            sync_percentage="100.0"
        fi
    else
        # Extract sync info
        current_block=$(echo "$sync_status" | grep -o '"currentBlock":"0x[^"]*' | cut -d'"' -f4)
        highest_block=$(echo "$sync_status" | grep -o '"highestBlock":"0x[^"]*' | cut -d'"' -f4)

        if [ -n "$current_block" ] && [ -n "$highest_block" ]; then
            # Convert hex to decimal
            current_block=$((16#${current_block:2}))
            highest_block=$((16#${highest_block:2}))

            # Calculate sync percentage
            if [ $highest_block -gt 0 ]; then
                sync_percentage=$(echo "scale=2; ($current_block * 100.0) / $highest_block" | bc)
            fi
        fi
    fi

    # Return JSON formatted status
    echo "{\"is_syncing\":$is_syncing,\"current_block\":\"$current_block\",\"highest_block\":\"$highest_block\",\"sync_percentage\":\"$sync_percentage\"}"
}

# Get consensus client sync status
get_consensus_status() {
    local is_syncing=true
    local sync_distance="unknown"
    local head_slot="unknown"
    local sync_percentage="unknown"

    # Get consensus sync status
    local sync_status=$(curl -s -X GET "${BEACON_ENDPOINT}/eth/v1/node/syncing" -H "accept: application/json")

    if [ $? -ne 0 ]; then
        log_message "Error: Failed to connect to consensus client"
        echo '{"is_syncing":true,"sync_distance":"unknown","head_slot":"unknown","sync_percentage":"unknown"}'
        return
    fi

    # Extract sync info
    is_syncing=$(echo "$sync_status" | grep -o '"is_syncing":[^,}]*' | cut -d':' -f2 | tr -d ' ')
    sync_distance=$(echo "$sync_status" | grep -o '"sync_distance":[^,}]*' | cut -d':' -f2 | tr -d '"}')

    # Get head slot from beacon chain head
    local head_response=$(curl -s -X GET "${BEACON_ENDPOINT}/eth/v1/beacon/headers/head" -H "accept: application/json")
    if [ $? -eq 0 ]; then
        head_slot=$(echo "$head_response" | grep -o '"slot":"[^"]*' | cut -d'"' -f4)
    fi

    # Calculate sync percentage if we have head and distance
    if [ "$sync_distance" != "unknown" ] && [ "$head_slot" != "unknown" ]; then
        if [ "$sync_distance" = "0" ]; then
            sync_percentage="100.0"
        else
            total_slots=$((head_slot + sync_distance))
            if [ $total_slots -gt 0 ]; then
                sync_percentage=$(echo "scale=2; ($head_slot * 100.0) / $total_slots" | bc)
            fi
        fi
    fi

    # Return JSON formatted status
    echo "{\"is_syncing\":$is_syncing,\"sync_distance\":\"$sync_distance\",\"head_slot\":\"$head_slot\",\"sync_percentage\":\"$sync_percentage\"}"
}

# Get checkpoint sync status
get_checkpoint_sync_status() {
    local checkpoint_log="${MONITOR_DIR}/checkpoint_sync.log"
    local checkpoint_url="unknown"
    local checkpoint_slot="unknown"
    local eta_seconds=0
    local download_status="unknown"
    local verification_status="unknown"
    local import_status="unknown"
    local finalization_status="unknown"

    # Check if checkpoint_sync_monitor.sh log exists
    if [ -f "{{ ephemery_base_dir }}/scripts/checkpoint_sync_monitor.sh" ]; then
        # Run the checkpoint monitor script to get current status
        {{ ephemery_base_dir }}/scripts/checkpoint_sync_monitor.sh --json > "${checkpoint_log}" 2>/dev/null

        if [ -f "${checkpoint_log}" ]; then
            # Extract checkpoint sync data
            checkpoint_url=$(grep -o '"source_url":"[^"]*' "${checkpoint_log}" | head -1 | cut -d'"' -f4)
            checkpoint_slot=$(grep -o '"slot":[0-9]*' "${checkpoint_log}" | head -1 | cut -d':' -f2)
            eta_seconds=$(grep -o '"eta_seconds":[0-9]*' "${checkpoint_log}" | head -1 | cut -d':' -f2)

            # Extract stage statuses
            download_status=$(grep -o '"download":{[^}]*}' "${checkpoint_log}" | head -1)
            verification_status=$(grep -o '"verification":{[^}]*}' "${checkpoint_log}" | head -1)
            import_status=$(grep -o '"import":{[^}]*}' "${checkpoint_log}" | head -1)
            finalization_status=$(grep -o '"finalization":{[^}]*}' "${checkpoint_log}" | head -1)
        fi
    fi

    # Return JSON formatted status
    echo "{\"source_url\":\"$checkpoint_url\",\"slot\":\"$checkpoint_slot\",\"eta_seconds\":$eta_seconds,\"stages\":{${download_status:10},${verification_status:14},${import_status:8},${finalization_status:14}}}"
}

# Update current status
update_status() {
    local execution_status=$(get_execution_status)
    local consensus_status=$(get_consensus_status)
    local checkpoint_status=$(get_checkpoint_sync_status)
    local timestamp=$(date +%s)

    # Create current status JSON
    local current_status=$(cat <<EOF
{
  "timestamp": $timestamp,
  "execution_client": "$EL_CLIENT",
  "consensus_client": "$CL_CLIENT",
  "execution_status": $execution_status,
  "consensus_status": $consensus_status,
  "checkpoint_sync": $checkpoint_status
}
EOF
)

    # Write to current status file
    echo "$current_status" > "${CURRENT_FILE}"

    # Update history file
    local history=$(cat "${HISTORY_FILE}")

    # Add new entry to history
    local updated_history=$(echo "$history" | jq ".sync_history += [$current_status]")

    # Trim history to keep only the last HISTORY_SIZE entries
    updated_history=$(echo "$updated_history" | jq ".sync_history = .sync_history | sort_by(.timestamp) | .[-${HISTORY_SIZE}:]")

    # Write updated history
    echo "$updated_history" > "${HISTORY_FILE}"

    log_message "Updated sync status - EL: $EL_CLIENT, CL: $CL_CLIENT"
}

# Main function
main() {
    log_message "Starting sync monitoring"

    update_status

    log_message "Sync monitoring completed"
}

# Run main function
main
